from typing import Union


class Ask:
    def __init__(self, choices=['y', 'n']):
        self.choices = choices

    def ask(self):
        if max(len(x) for x in self.choices) > 1:
            for i, x in enumerate(self.choices):
                print(f"{i}. {x}")
            while True:
                try:
                    idx = int(input("номер варианта: "))
                    if 0 <= idx < len(self.choices):
                        return self.choices[idx]
                except ValueError:
                    pass
        else:
            print("/".join(self.choices))
            ans = input().strip().lower()
            return ans or self.choices[0]


class Content:
    def __init__(self, x):
        self.x = x

class If(Content):
    pass

class AND(Content):
    pass

class OR(Content):
    pass

Rule = Union[Ask, If, AND, OR, list[str]]

class KnowledgeBase:
    def __init__(self, rules: dict[str, Rule]):
        self.rules = rules
        self.memory = {}

    def get(self, name):
        if name in self.memory:
            return self.memory[name]

        for fld in self.rules.keys():
            if fld == name or fld.startswith(name + ":"):
                value = 'y' if fld == name else fld.split(':', 1)[1]
                res = self.eval(self.rules[fld], field=name)
                if res == 'y':
                    self.memory[name] = value
                    return value

        res = self.eval(self.rules['default'], field=name)
        self.memory[name] = res
        return res

    def eval(self, expr, field=None):
        if isinstance(expr, Ask):

            if isinstance(field, str):
                label = field.replace('_', ' ')
            else:
                label = "уточните"

            print(f"\n{label}?")
            return expr.ask()

        elif isinstance(expr, If):
            return self.eval(expr.x, field=field)

        elif isinstance(expr, AND) or isinstance(expr, list):
            vals = expr.x if isinstance(expr, AND) else expr
            for x in vals:
                if self.eval(x) == 'n':
                    return 'n'
            return 'y'

        elif isinstance(expr, OR):
            for x in expr.x:
                if self.eval(x) == 'y':
                    return 'y'
            return 'n'

        elif isinstance(expr, str):
            return self.get(expr)

        else:
            return 'n'

# Рекомендации по оптимизации энергопотребления в доме или офисе.

# будут спрашиваться по default
questions = [
    'считаете_текущие_счета_за_электричество_высокими',
    'считаете_счета_за_отопление_высокими',
    'есть_сквозняки_или_холодные_стены_зимой',
    'окна_старые_или_без_двойного_стеклопакета',
    'освещение_преимущественно_на_лампах_накаливания',
    'часто_используете_дополнительные_обогреватели',
    'много_компьютеров_и_офисной_техники',
    'техника_часто_работает_когда_никого_нет',
    'есть_старая_бытовая_техника_класс_энергоэффективности_ниже_a',
    'нет_термостатов_или_программируемых_таймеров',
    'можете_влиять_на_привычки_жильцов_или_сотрудников',
    'уже_частично_занимались_сокращением_энергопотребления',
]

rules: dict[str, Rule] = {
    'default': Ask(['y', 'n']),
    'сильные_теплопотери': If(OR([
        'есть_сквозняки_или_холодные_стены_зимой',
        'окна_старые_или_без_двойного_стеклопакета',
        'считаете_счета_за_отопление_высокими',
    ])),
    
    'высокое_электропотребление_из_за_техники': If(OR([
        'считаете_текущие_счета_за_электричество_высокими',
        'много_компьютеров_и_офисной_техники',
        'техника_часто_работает_когда_никого_нет',
    ])),
    
    'проблемы_и_по_теплу_и_по_электричеству': If(OR([
        'считаете_текущие_счета_за_электричество_высокими',
        AND(['сильные_теплопотери', 'высокое_электропотребление_из_за_техники']),
    ])),
    
    'относительно_сбалансированное_потребление': If('уже_частично_занимались_сокращением_энергопотребления'),
    
    'есть_ограничения_по_модернизации': If(OR([
        'арендованное_помещение',
        'нельзя_менять_окна_и_отопление',
    ])),
    
    'пиковые_нагрузки_в_рабочие_часы': If(OR([
        'много_компьютеров_и_офисной_техники',
        'техника_часто_работает_когда_никого_нет',
    ])),
    
    'освещение_требует_оптимизации': If(OR([
        'освещение_преимущественно_на_лампах_накаливания',
        'нет_термостатов_или_программируемых_таймеров',
    ])),
    
    'профиль:большие_потери_через_ограждающие_конструкции': If(AND([
        'сильные_теплопотери',
        'есть_ограничения_по_модернизации',
    ])),
    
    'профиль:высокое_электропотребление_офисной_техники': If(AND([
        'высокое_электропотребление_из_за_техники',
        'пиковые_нагрузки_в_рабочие_часы',
    ])),
    
    'профиль:смешанные_проблемы_тепло_и_электричество': If(AND([
        'проблемы_и_по_теплу_и_по_электричеству',
        'есть_ограничения_по_модернизации',
    ])),
    
    'профиль:относительно_сбалансированное_потребление': If('относительно_сбалансированное_потребление'),
    
    'профиль:освещение_главный_потребитель': If(AND([
        'освещение_требует_оптимизации',
    ])),
}

recommendations = {
    'большие_потери_через_ограждающие_конструкции': '\nограждающие конструкции: устраните щели, утеплите стены, пол и чердак, особенно угловые комнаты;\nокна: по возможности установите двух- или тройные стеклопакеты, временно используйте уплотнители и энергосберегающую плёнку;\nотопление: поставьте термоголовки на радиаторы и поддерживайте 20–22 °C в жилых комнатах;\nмониторинг: снимайте показания счётчиков и сравнивайте расход до и после мероприятий.',
    'высокое_электропотребление_офисной_техники': '\nоборудование: инвентаризируйте технику, отключите лишние устройства, переведите остальное в энергосберегающие режимы;\nрабочие места: настройте автоматическую блокировку и режим сна на ПК и мониторах через 5–10 минут простоя;\nсерверная и печать: по возможности объедините задачи на несколько энергоэффективных устройств, отключите лишние принтеры;\nорганизация: введите правило “последний уходящий проверяет технику” и закрепите его в регламенте.',
    'смешанные_проблемы_тепло_и_электричество': '\nприоритизация: начните с самых дешёвых мер – уплотнение окон и дверей, настройка термостатов, отключение техники в нерабочее время;\nосвещение: замените лампы накаливания и галогенные светильники на светодиодные, особенно в коридорах и зонах общего пользования;\nповедение: договоритесь о базовых правилах – не перекрывать радиаторы мебелью, закрывать окна при включённом отоплении, гасить свет при выходе;\nплан: составьте список улучшений на год с примерной экономией и постепенно реализуйте их по мере бюджета.',
    'относительно_сбалансированное_потребление': '\nмониторинг: раз в месяц фиксируйте показания счётчиков и сравнивайте с прошлым годом;\nтонкая настройка: проверьте, нет ли помещений, которые отапливаются или освещаются без необходимости, оптимизируйте графики;\ноборудование: при замене техники выбирайте модели не ниже класса A++, учитывайте потребление в режиме ожидания;\nдальнейшие шаги: подумайте о более “продвинутых” мерах — умные розетки, датчики движения, системы умного дома/офиса.',
    'освещение_главный_потребитель': '\nзамена светильников: постепенно замените все лампы накаливания и галогенные лампы на светодиодные с подходящей цветовой температурой;\nзоны общего пользования: установите датчики движения или таймеры в коридорах, санузлах, складских помещениях;\nрабочие места: используйте локальное освещение (настольные лампы) вместо чрезмерно яркого общего света;\nэксперимент: в течение месяца контролируйте, где свет чаще всего забывают выключать, и подумайте о техническом решении (датчики, таблички, сценарии).'
}


def main():
    kb = KnowledgeBase(rules)
    profile = kb.get('профиль')
    
    print(f"определённый профиль энергопотребления: {profile}")

    rec = recommendations.get(profile)
    if rec:
        print(rec)
    else:
        print("профиль не удалось определить однозначно. "
            "рекомендуются базовые меры экономии: отключать лишний свет и технику,"
            " следить за режимом отопления и уплотнением окон.")


if __name__ == '__main__':
    main()
